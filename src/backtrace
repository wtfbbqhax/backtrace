#!/bin/bash
# backtrace by Victor Roemer (WTFBBQHAX) <victor [at] badsec.org>.

# This script was originally designed to report Razorback crashes
# that occurred in the QA test-network.

cd /var/tmp

# global variable of files to remove
JUNKFILES=
# for generating the gdb command files on the fly, also appends
# filename to JUNKFILES for later removal via cleanup()
write_commands()
{
    local file=$1
    local commands=$2

    JUNKFILES="$JUNKFILES $file"

    echo -e $commands > $file
}

# remove the autogenerated files
cleanup()
{
    rm -f $JUNKFILES 
}

# get the path to the crashed executable
program_sauce()
{
    local input=$1
    local ret=

    case "$input" in
        # Lazy as shit name matching
        *dispatcher*)
            ret="/opt/razorback/bin/dispatcher"
            ;;
        *masterNugget*)
            ret="/opt/razorback/bin/masterNugget"
            ;;
        *fileInject*)
            ret="/opt/razorback/bin/fileInject"
            ;;
        *fsMonitor*)
            ret="/opt/razorback/bin/fsMonitor"
            ;;
        *fsWalk*)
            ret="/opt/razorback/bin/fsWalk"
            ;;
        *snort*)
            ret="/opt/razorback/bin/snort"
            ;;

        # DEFAULT look the command up in $PATH
        # hehe, can't be lazy this time though
        *)
            ret=${input#"Core was generated by \`"}
            ret=${ret%"\'."}
            ret=$(which $ret)
            ;;
    esac

    echo $ret
}

# crack open the core file to figure out what crashed
what_fucked_up()
{
    local core=$1

    write_commands 'quit.gdb' 'quit'
    local sauce=$(gdb -q -batch -x quit.gdb -c $core |egrep 'Core was generated by')
    echo $(program_sauce "$sauce")
}

# get a backtrace from the core, needs the path to the crashed
# executable as well
backtrace()
{
    local core=$1
    local prog=$2

    echo "CORE: $core"
    echo -e "PROGRAM: $prog\n"

    commands="backtrace\nquit"

    write_commands 'bt.gdb' "$commands"

    if [[ $core && $prog ]]; then 
        /usr/bin/gdb -q -batch -x bt.gdb -c $core $prog
    fi
}


# Simple method of not re-evaluating the same cores, the distinguishing
# difference between un-analyzed and analyzed is a + sign prepended to the
# core dump name.
mark()
{
    local core=$1
    local name="+core${core#core}"

    echo "mv $core $name"
    mv $core $name
}

# M A I N

CORES=$(ls core.* 2> /dev/null)

if [[ $CORES ]]; then
    for i in $CORES
    do
        echo $(hostname)
        echo "======================================================================="

        SAUCE=$(what_fucked_up $i)

        if [[ $SAUCE ]]; then
            backtrace $i $SAUCE
        fi
        mark $i
        echo "" # newline
    done
fi

cleanup
